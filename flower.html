<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Flower Wave (String Effect)</title>
    <style>
        /* Base Styles */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA); /* Sky to light blue background */
            height: 100vh;
            width: 100vw;
        }
        
        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        /* Flower Styles - optimized for performance */
        .flower {
            position: absolute;
            bottom: 0; /* Anchor point for the wave */
            left: 0;
            pointer-events: none;
            /* Use transform for animation; removed CSS transition for frame-by-frame updates */
            will-change: transform, opacity, filter;
        }
        
        .flower img {
            display: block;
            width: 100%;
            height: auto;
            /* Ensures the center of the wave is the bottom of the flower */
            transform-origin: 50% 100%;
            filter: drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));
        }
    </style>
</head>
<body>
    <div id="container">
        </div>

    <script>
        class FlowerWave {
            constructor() {
                this.container = document.getElementById('container');
                this.flowerElements = [];
                this.flowerImages = [];
                this.time = 0;

                // --- Configuration ---
                this.FLOWER_COUNT = 70; // Total number of flowers on the screen
                this.FLOWER_SPACING = 30; // Horizontal distance between flowers on the path
                this.FLOW_SPEED = 2.0; // Speed of the wave's horizontal flow (pixels per frame)

                // Wave Parameters (The shape of the trailing string)
                this.WAVE_AMPLITUDE = 100; // Max height of the wave in pixels
                this.WAVE_FREQUENCY = 0.005; // How compressed the wave is horizontally
                this.WAVE_PHASE_SPEED = 0.03; // Speed of the wave's movement (how fast it propagates)

                // Depth parameters (Simplified from your original and Python code)
                this.depthLayers = {
                    TINY: { scale: 0.6, opacity: 0.5, blur: 2.5, zIndex: 1, speedMult: 0.8 },
                    SMALL: { scale: 1.0, opacity: 0.8, blur: 1.0, zIndex: 5, speedMult: 1.0 },
                    MEDIUM: { scale: 1.5, opacity: 1.0, blur: 0.0, zIndex: 10, speedMult: 1.2 }
                };

                this.init();
            }

            // --- Initialization ---

            async init() {
                await this.loadFlowerAssets();
                if (this.flowerImages.length === 0) {
                    console.error("No flower images loaded. Check your 'anime_flowers_processed' folder.");
                    return;
                }
                this.createFlowerElements();
                this.animate();
            }

            async loadFlowerAssets() {
                // Reuse your robust loading logic to load all available images
                for (let i = 1; i <= 100; i++) {
                    const filename = `anime_flowers_processed/anime-flower-${i.toString().padStart(3, '0')}.png`;
                    try {
                        const img = new Image();
                        img.src = filename;
                        await new Promise((resolve, reject) => {
                            img.onload = resolve;
                            // Treat 404/error as the end of the image sequence
                            img.onerror = () => reject(new Error('Image load failed or does not exist')); 
                        });
                        this.flowerImages.push({
                            image: img,
                            id: i
                        });
                    } catch (error) {
                        break; // Stop loading on the first missing file
                    }
                }
                console.log(`Loaded ${this.flowerImages.length} unique flower images.`);
            }

            createFlowerElements() {
                const layers = Object.keys(this.depthLayers);
                
                for (let i = 0; i < this.FLOWER_COUNT; i++) {
                    // Randomly select image and depth layer for each element
                    const flowerData = this.flowerImages[Math.floor(Math.random() * this.flowerImages.length)];
                    const layerKey = layers[Math.floor(Math.random() * layers.length)];
                    const layerConfig = this.depthLayers[layerKey];

                    const element = document.createElement('div');
                    element.className = 'flower';
                    element.style.zIndex = layerConfig.zIndex;

                    const imgEl = document.createElement('img');
                    imgEl.src = flowerData.image.src;
                    
                    // Apply depth styles via CSS properties
                    imgEl.style.width = `${flowerData.image.naturalWidth * layerConfig.scale}px`;
                    element.style.opacity = layerConfig.opacity;
                    element.style.filter = `blur(${layerConfig.blur}px)`;

                    element.appendChild(imgEl);
                    this.container.appendChild(element);

                    this.flowerElements.push({
                        element: element,
                        layerConfig: layerConfig,
                        // Initial position offset on the horizontal path
                        pathOffset: i * this.FLOWER_SPACING, 
                        // Start the element outside the right edge
                        x_pos: window.innerWidth + i * this.FLOWER_SPACING, 
                        // Start the element at the bottom of the screen
                        y_pos: window.innerHeight, 
                        width: flowerData.image.naturalWidth * layerConfig.scale
                    });
                }
            }

            // --- Animation Loop ---

            updateFlowerPositions() {
                const W = window.innerWidth;
                const H = window.innerHeight;

                this.time += 0.016; // Time increment for wave animation

                this.flowerElements.forEach(flower => {
                    const config = flower.layerConfig;
                    
                    // 1. Move the flower left based on flow speed and depth multiplier
                    flower.x_pos -= this.FLOW_SPEED * config.speedMult;

                    // 2. Calculate the dynamic wave path
                    // The wave's vertical position is based on the current X position and the time (phase)
                    const waveY = this.WAVE_AMPLITUDE * Math.sin(
                        (flower.x_pos * this.WAVE_FREQUENCY) + (this.time * this.WAVE_PHASE_SPEED * config.speedMult)
                    );
                    
                    // 3. Final Y position: Starts from the bottom anchor (H) and follows the wave
                    // We subtract `flower.width` since we are transforming the element's top-left corner
                    const y_transform = H + waveY - (flower.width || 0); 
                    
                    // 4. Apply transformation (using translate3d for better performance)
                    flower.element.style.transform = `translate3d(${flower.x_pos}px, ${y_transform}px, 0)`;

                    // 5. Recycling (The "car" has passed this flower)
                    if (flower.x_pos < -flower.width) {
                        // Reset the flower to the far right to re-enter the wave
                        flower.x_pos = W + this.FLOWER_SPACING * 2;
                        
                        // Give it a random layer/speed again for variety
                        const layers = Object.keys(this.depthLayers);
                        const newLayerKey = layers[Math.floor(Math.random() * layers.length)];
                        flower.layerConfig = this.depthLayers[newLayerKey];
                        
                        // Re-apply visual styles for the new layer
                        flower.element.style.zIndex = flower.layerConfig.zIndex;
                        flower.element.style.opacity = flower.layerConfig.opacity;
                        flower.element.style.filter = `blur(${flower.layerConfig.blur}px)`;
                    }
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.updateFlowerPositions();
            }
        }

        // Initialize the flower wave when page loads
        window.addEventListener('load', () => {
            new FlowerWave();
        });
    </script>
</body>
</html>
