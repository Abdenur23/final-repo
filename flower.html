<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Flower Wave</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Hide flowers when they move off-screen */
            background-color: #f7f7f7; /* Light background for contrast */
            height: 100vh;
            width: 100vw;
        }

        /* The container for all flowers */
        #flower-wave-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* Base styling for a single flower element */
        .flower {
            position: absolute;
            left: 0;
            bottom: 0;
            transition: opacity 0.3s ease-out, transform 0.1s linear; /* Smooth fade-out */
            will-change: transform, opacity; /* Performance optimization */
        }
        
        .flower img {
            display: block;
            pointer-events: none; /* Ignore mouse clicks on the image itself */
            transform-origin: bottom left; /* Rotate around the base */
        }
    </style>
</head>
<body>

<div id="flower-wave-container">
    </div>

<script>
    // --- Configuration ---
    const FLOWER_COUNT = 70; // Total number of flower elements in the wave
    const FLOWER_SIZE = 80; // Base size in pixels (matches target_size=80 in your Python script)
    const ASSET_FOLDER = 'anime_flowers_processed'; // Subfolder name
    const FLOWER_PREFIX = 'anime-flower-'; // Match your file naming convention

    // Flower Depth-of-Field (DOF) styles (Simplified from your Python script)
    // Affects size (scale) and transparency (opacity)
    const DOF_STYLES = {
        // TINY and SMALL are far/blurry. MEDIUM is close/sharp.
        TINY: { scale: [0.6, 0.9], opacity: [0.4, 0.7] },
        SMALL: { scale: [0.9, 1.3], opacity: [0.7, 0.9] },
        MEDIUM: { scale: [1.3, 1.8], opacity: [0.9, 1.0] }
    };

    // Wave configuration (tuned for a string-like movement)
    const WAVE_AMPLITUDE = 0.15; // Max wave height as a fraction of screen height (15%)
    const WAVE_FREQUENCY = 0.005; // Horizontal compression/stretch
    const WAVE_SPEED = 0.005; // Speed of the wave's horizontal movement
    
    // Horizontal space flowers cover (from 0% to MAX_WAVE_WIDTH_PCT)
    const MAX_WAVE_WIDTH_PCT = 120; // 120% of screen width to allow them to flow off-screen

    // --- Utility Functions ---

    /** Get random value within range */
    function randRange(min, max) {
        return Math.random() * (max - min) + min;
    }

    /** Pre-calculate flower styles based on depth */
    function createFlowerData(count) {
        const styles = ['TINY', 'SMALL', 'MEDIUM'];
        let data = [];
        
        // Randomly assign depth styles
        for (let i = 0; i < count; i++) {
            const styleKey = styles[Math.floor(randRange(0, styles.length))];
            const style = DOF_STYLES[styleKey];
            const size = FLOWER_SIZE * randRange(...style.scale);
            
            data.push({
                // Select a random flower index (assuming files are 1-based, e.g., 001.png to N.png)
                fileIndex: Math.floor(randRange(1, 10)), // Assuming at least 10 flowers exist
                size: size,
                opacity: randRange(...style.opacity),
                style: styleKey
            });
        }
        return data;
    }

    // --- Core Logic ---

    // Array to hold the dynamic properties of each flower
    const flowerElements = [];
    const flowerData = createFlowerData(FLOWER_COUNT);

    /** Initialize all flower elements and append them to the DOM */
    function initializeFlowers() {
        const container = document.getElementById('flower-wave-container');

        flowerData.forEach((data, i) => {
            const flowerEl = document.createElement('div');
            flowerEl.className = 'flower';
            flowerEl.style.zIndex = data.style === 'MEDIUM' ? 10 : (data.style === 'SMALL' ? 5 : 1);
            
            const imgEl = document.createElement('img');
            // Construct the path to the PNG image
            const imgNumber = String(data.fileIndex).padStart(3, '0');
            imgEl.src = `${ASSET_FOLDER}/${FLOWER_PREFIX}${imgNumber}.png`;
            imgEl.alt = 'Flower';
            imgEl.style.width = `${data.size}px`;
            imgEl.style.height = `${data.size}px`;

            flowerEl.appendChild(imgEl);
            container.appendChild(flowerEl);
            
            // Store the element reference and its static data
            flowerElements.push({
                element: flowerEl,
                img: imgEl,
                data: data,
                // Assign a unique position/time offset along the wave (from 0 to 1)
                t_offset: i / (FLOWER_COUNT - 1) 
            });
        });
    }

    /** Update the position of all flowers based on the dynamic wave path */
    let time = 0; // Global time variable for wave movement
    function updateWave() {
        const W = window.innerWidth;
        const H = window.innerHeight;
        const A = H * WAVE_AMPLITUDE; // Actual wave amplitude in pixels

        // The 'car' moves off the left side of the screen over time
        const waveShift = time * WAVE_SPEED * W; 

        flowerElements.forEach((flower, i) => {
            const t = flower.t_offset; // Position along the string (0 to 1)
            
            // 1. Calculate the target X position: starts off-screen right and moves left
            // It goes from W * MAX_WAVE_WIDTH_PCT at t=0 to 0 at t=1
            const waveWidth = W * (MAX_WAVE_WIDTH_PCT / 100);
            let x_initial = W - (t * waveWidth); 
            
            // Add the wave shift (makes the entire wave pattern move left)
            let x_pos = x_initial - waveShift;
            
            // 2. Calculate the wave Y position (like a string being dragged)
            // Use sine wave for a clean, continuous path
            const waveY = Math.sin(x_pos * WAVE_FREQUENCY) * A;

            // 3. Final Y position: Starts from the bottom and follows the wave path
            // The wave crests are *above* the bottom line (H)
            let y_pos = H + waveY; // Start at the bottom (H) and add/subtract wave height (A)

            // 4. Calculate Alpha (fade-in/fade-out)
            let opacity = flower.data.opacity;
            
            // Fade-in from the bottom-left corner
            if (x_pos > W * 0.95) { // If near the far right edge (string attachment point)
                 opacity = 0; // Force hidden at the far end before it enters the screen
            } else if (x_pos > W) {
                // Flowers before they enter the screen are hidden
                opacity = 0;
            } else if (x_pos > W * 0.8) {
                // Fade in as they enter the screen (from 80% to 100% of W)
                opacity = flower.data.opacity * (1 - (x_pos - W * 0.8) / (W * 0.2)); 
            } else if (x_pos < -flower.data.size) { 
                // Fade out/hide completely after they exit the screen on the left
                opacity = 0;
            }
            
            // 5. Apply transformations and opacity
            flower.element.style.opacity = opacity;
            
            // Use CSS transform for smooth, hardware-accelerated movement
            // Flowers start at bottom-left corner (0, H) and flow up and along the wave.
            flower.element.style.transform = `translate3d(${x_pos}px, ${y_pos}px, 0)`;

        });

        // Increment time for the next frame
        time += 1;
        
        // Use requestAnimationFrame for smooth animation
        requestAnimationFrame(updateWave);
    }

    // --- Execution ---

    initializeFlowers();
    // Set the initial position of the 'car' to start the wave near the bottom left
    document.getElementById('flower-wave-container').style.transform = `translateY(-${FLOWER_SIZE}px) translateX(-${FLOWER_SIZE/2}px)`; 
    
    // Start the animation loop
    updateWave();

</script>

</body>
</html>
