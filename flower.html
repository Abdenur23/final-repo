<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Flower Wave (Fixed Scale & Dynamic DOF)</title>
    <style>
        body {
            margin: 0; padding: 0; overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
            height: 100vh; width: 100vw;
        }
        #container {
            position: absolute;
            top: 0;
            left: 0;
            /* The container now holds the fixed-size virtual canvas */
            width: 100%; 
            height: 100%; 
            transform-origin: 0 0; /* Ensures correct scaling from top-left */
        }
        .flower {
            position: absolute; pointer-events: none;
            will-change: transform, opacity, filter;
            bottom: 0; left: 0; 
        }
        .flower img {
            display: block; width: 100%; height: auto;
            transform-origin: 50% 100%;
            filter: drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));
        }
    </style>
</head>
<body>
    <div id="container">
    </div>

    <script>
        function randRange(min, max) {
            return Math.random() * (max - min) + min;
        }

        function map(value, inMin, inMax, outMin, outMax) {
            return (value - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
        }

        class FlowerWave {
            constructor() {
                this.container = document.getElementById('container');
                this.flowerElements = [];
                this.flowerImages = [];
                this.time = 0;
                
                // --- NEW: FIXED VIRTUAL CANVAS DIMENSIONS ---
                // All flower calculations are based on this width
                this.VIRTUAL_WIDTH = 1440; 
                this.VIRTUAL_HEIGHT = 800; // Used for vertical scale reference

                // --- Configuration ---
                this.FLOWER_COUNT = 200; 
                this.FLOW_SPEED = 1.0; 
                this.FLOWER_SPACING = 25; 

                // Flower Size (based on VIRTUAL_WIDTH)
                this.MAX_FLOWER_SIZE_FRAC = 0.12; 
                
                // --- WAVE PARAMETERS (based on VIRTUAL_HEIGHT) ---
                this.WAVE_AMPLITUDE = 250; 
                this.WAVE_FREQUENCY = 0.005; 
                this.WAVE_PHASE_SPEED = 0.02; 
                
                // Defines the maximum vertical spread (depth)
                this.WAVE_HEIGHT = 600; 
                
                // --- DEPTH & PROPORTION ---
                const pythonMediumMax = 0.048; 
                const pythonTinyMin = 0.006;
                const pythonSmallMin = 0.013;
                const pythonSmallMax = 0.028;
                const pythonMediumMin = 0.028;

                this.PROPORTIONAL_LAYERS = {
                    "TINY": { 
                        P_CUM: 0.65, 
                        size_range: [pythonTinyMin / pythonMediumMax, pythonTinyMax / pythonMediumMax],
                        opacity_range: [0.65, 0.85], 
                        blur_range: [1.0, 2.0], // Max blur for furthest flowers
                        zIndex: 1, speedMult: 0.8 
                    },
                    "SMALL": { 
                        P_CUM: 0.95, 
                        size_range: [pythonSmallMin / pythonMediumMax, pythonSmallMax / pythonMediumMax],
                        opacity_range: [0.80, 0.95], 
                        blur_range: [0.5, 1.5], 
                        zIndex: 5, speedMult: 1.0 
                    },
                    "MEDIUM": { 
                        P_CUM: 1.0, 
                        size_range: [pythonMediumMin / pythonMediumMax, 1.0], 
                        opacity_range: [0.90, 1.00], 
                        blur_range: [0.0, 0.5], // Foreground is mostly sharp
                        zIndex: 10, speedMult: 1.2 
                    }
                };
                
                window.addEventListener('resize', this.handleResize.bind(this));
                this.handleResize(); // Initial scaling
                this.init();
            }

            // --- NEW: SCALE HANDLER ---
            handleResize() {
                const W = window.innerWidth;
                const H = window.innerHeight;
                
                // Calculate the scale factor (only scales based on width)
                const scaleX = W / this.VIRTUAL_WIDTH;
                const scaleY = H / this.VIRTUAL_HEIGHT;
                
                // Use a combination of scale factors to keep a good view
                // For a wave anchored to the bottom, we usually only scale by width (scaleX)
                // but we also need to adjust the position of the container
                this.container.style.width = `${this.VIRTUAL_WIDTH}px`;
                this.container.style.height = `${this.VIRTUAL_HEIGHT}px`;
                
                // Scale the entire virtual canvas to fit the screen width
                this.container.style.transform = `scale(${scaleX})`;
                
                // Since the height isn't fully contained, we need to adjust the bottom position
                // We anchor the container to the bottom edge using the height difference
                const translateY = H - (this.VIRTUAL_HEIGHT * scaleX);
                this.container.style.transform = `scale(${scaleX}) translateY(${translateY / scaleX}px)`;
                
            }
            // --- End Scale Handler ---

            // --- Function to Calculate Depth Properties (Updated for Dynamic DOF) ---
            calculateDepthProps(layerConfig, depthPhase) {
                // depthPhase cycles from 0 (deep/blurry) to 1 (shallow/clear) and back to 0
                
                const blurRange = layerConfig.blur_range;
                const opacityRange = layerConfig.opacity_range;

                if (layerConfig.zIndex === 10) { // MEDIUM (Foreground)
                    // MEDIUM flowers always stay sharpest/clearest
                    return { 
                        blur: randRange(blurRange[0], blurRange[1]),
                        opacity: randRange(opacityRange[0], opacityRange[1])
                    };
                }
                
                // For SMALL and TINY, interpolate between the blurry (deep) and clear (shallow) ends
                // When depthPhase is 0, they are max blur, min opacity (furthest)
                // When depthPhase is 1, they are min blur, max opacity (closest)
                
                const blur = map(depthPhase, 0, 1, blurRange[1], blurRange[0]);
                const opacity = map(depthPhase, 0, 1, opacityRange[0], opacityRange[1]);
                
                return { 
                    blur: Math.max(blurRange[0], blur * randRange(0.9, 1.1)),
                    opacity: Math.min(opacityRange[1], opacity * randRange(0.95, 1.05))
                };
            }

            // --- Flower Creation (Updated to use VIRTUAL_WIDTH) ---
            createFlowerElements() {
                const W = this.VIRTUAL_WIDTH;
                
                for (let i = 0; i < this.FLOWER_COUNT; i++) {
                    const flowerData = this.flowerImages[Math.floor(Math.random() * this.flowerImages.length)];
                    
                    const p = Math.random();
                    let layerKey = 'TINY'; 
                    if (p > this.PROPORTIONAL_LAYERS['TINY'].P_CUM) {
                         layerKey = p <= this.PROPORTIONAL_LAYERS['SMALL'].P_CUM ? 'SMALL' : 'MEDIUM';
                    }
                    const layerConfig = this.PROPORTIONAL_LAYERS[layerKey];

                    const [sizeMinMult, sizeMaxMult] = layerConfig.size_range;
                    const maxFlowerWidthPx = W * this.MAX_FLOWER_SIZE_FRAC;
                    const targetWidth = randRange(maxFlowerWidthPx * sizeMinMult, maxFlowerWidthPx * sizeMaxMult);
                    
                    // NEW: Assign a random starting point in the depth cycle (0 to 2*PI)
                    const depthPhaseOffset = randRange(0, Math.PI * 2);
                    
                    // Calculate initial depth properties
                    const depthPhase = 0.5 + 0.5 * Math.cos(depthPhaseOffset); // Initial phase (0 to 1)
                    const { blur, opacity } = this.calculateDepthProps(layerConfig, depthPhase);
                    
                    const element = document.createElement('div');
                    element.className = 'flower';
                    element.style.zIndex = layerConfig.zIndex;

                    const imgEl = document.createElement('img');
                    imgEl.src = flowerData.image.src;
                    imgEl.style.width = `${targetWidth}px`;
                    
                    element.style.opacity = opacity;
                    element.style.filter = `blur(${blur}px)`;

                    element.appendChild(imgEl);
                    this.container.appendChild(element);

                    this.flowerElements.push({
                        element: element,
                        layerConfig: layerConfig,
                        x_pos: W + i * this.FLOWER_SPACING, 
                        scaledWidth: targetWidth,
                        // NEW: Vertical offset and depth cycle phase are separate
                        waveYOffset: randRange(0, this.WAVE_HEIGHT), 
                        depthPhaseOffset: depthPhaseOffset,
                        depthSpeed: randRange(0.3, 0.6) * layerConfig.speedMult, // Speed of blur/unblur cycle
                    });
                }
            }

            // --- Animation Loop ---
            updateFlowerPositions() {
                const W = this.VIRTUAL_WIDTH;
                
                this.time += 0.016; 

                this.flowerElements.forEach(flower => {
                    const config = flower.layerConfig;
                    
                    // 1. Horizontal Movement 
                    flower.x_pos -= this.FLOW_SPEED * config.speedMult;

                    // 2. Wave Motion (Y offset)
                    const waveY = this.WAVE_AMPLITUDE * Math.sin(
                        (flower.x_pos * this.WAVE_FREQUENCY) + (this.time * this.WAVE_PHASE_SPEED * config.speedMult)
                    );
                    
                    // 3. Dynamic Depth Cycle
                    flower.depthPhaseOffset += 0.01 * flower.depthSpeed;
                    const depthPhase = 0.5 + 0.5 * Math.cos(flower.depthPhaseOffset); // Cycles 0 -> 1 -> 0
                    
                    // 4. Vertical Transformation (Y position is now static waveYOffset + dynamic waveY)
                    const y_transform = -(flower.waveYOffset + waveY);
                    
                    // 5. Apply Position Transform
                    flower.element.style.transform = `translate3d(${flower.x_pos}px, ${y_transform}px, 0)`;

                    // 6. Apply Dynamic Depth Styles (Blurring Back and Forth)
                    const { blur, opacity } = this.calculateDepthProps(config, depthPhase);
                    flower.element.style.opacity = opacity;
                    flower.element.style.filter = `blur(${blur}px)`;


                    // 7. Recycling
                    if (flower.x_pos < -flower.scaledWidth) {
                        flower.x_pos = W + this.FLOWER_SPACING * 2;
                        
                        // [Flower recycling logic remains the same for layer/size/z-index]
                        const p = Math.random();
                        let newLayerKey = 'TINY';
                        if (p > this.PROPORTIONAL_LAYERS['TINY'].P_CUM) {
                            newLayerKey = p <= this.PROPORTIONAL_LAYERS['SMALL'].P_CUM ? 'SMALL' : 'MEDIUM';
                        }
                        const newConfig = this.PROPORTIONAL_LAYERS[newLayerKey];
                        flower.layerConfig = newConfig;

                        const [sizeMinMult, sizeMaxMult] = newConfig.size_range;
                        const maxFlowerWidthPx = W * this.MAX_FLOWER_SIZE_FRAC;
                        const newWidth = randRange(maxFlowerWidthPx * sizeMinMult, maxFlowerWidthPx * sizeMaxMult);
                        flower.scaledWidth = newWidth;
                        flower.element.firstChild.style.width = `${newWidth}px`;
                        flower.element.style.zIndex = newConfig.zIndex;
                        
                        // Reset depth cycle for new flower
                        flower.depthPhaseOffset = randRange(0, Math.PI * 2); 
                        flower.depthSpeed = randRange(0.3, 0.6) * newConfig.speedMult;
                        
                        // Randomize wave path offset
                        flower.waveYOffset = randRange(0, this.WAVE_HEIGHT); 
                    }
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.updateFlowerPositions();
            }
        }

        window.addEventListener('load', () => {
            new FlowerWave();
        });
    </script>
</body>
</html>
